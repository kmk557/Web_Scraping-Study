
    정리 사이트  https://wikidocs.net/4308


[ 파이썬에서 정규 표현식을 지원하는 re(regular expression) 모듈 ]

    re.compile('ab*')   미리 정규식을 정한다 (= 정규식을 컴파일 한다)
        DOTALL(S) - . 이 줄바꿈 문자를 포함하여 모든 문자와 매치할 수 있도록 한다.
                    (원래는 . \n을 포함하지 못한다.)

        IGNORECASE(I) - 대소문자에 관계없이 매치할 수 있도록 한다.

        MULTILINE(M) - 메타 문자를 문자열의 각 라인마다 적용해 준다. (^, $ 메타문자의 사용과 관계가 있는 옵션이다)

                        ^ 메타 문자를 문자열 전체의 처음이 아니라 각 라인의 처음으로 인식시키고 싶은 경우도 있을 것이다.
                         이럴 때 사용할 수 있는 옵션이 바로 re.MULTILINE 또는 re.M이다.

        VERBOSE(X) - verbose 모드를 사용할 수 있도록 한다. (복잡한 정규식을 보기 편하게 만들수 있고 주석등을 사용할 수 있게된다.)

                        re.VERBOSE 옵션을 사용하면 문자열에 사용된 whitespace는 컴파일 시 제거된다
                        (단 [ ] 내에 사용된 whitespace는 제외).
                        그리고 줄 단위로 #기호를 이용하여 주석문을 작성할 수 있다.

            옵션을 사용할 때는 re.DOTALL처럼 전체 옵션명을 써도 되고 re.S처럼 약어를 써도 된다.

            ex) p = re.compile('a.b', re.DOTALL)
                m = p.search("5 python")

    re.match()	문자열의 처음부터 정규식과 매치되는지 조사한다.
                처음부터 시작해서 가장 먼저 정규식과 매치되지 않는 곳을 찾는다

    re.search()     true or false 를 반환

    re.findall()    찾은 값을 리스트 형태로 반환

    re.finditer()	정규식과 매치되는 모든 문자열(substring)을 iterator 객체로 리턴한다

[정규표현식]

    특수문자 사용법
         //          문자 '/'를 의미

        r''         Raw String  이라는 것을 의미
                    (메타문자 무시?)
            ex)
            '\\abc' = \abc
            r'\\abc' = \\abc

    ^           라인의 처음을 매칭
    (re.search('^From:', line) = line.startswith('From:')

    $            라인의 끝을 매칭

    .             임의의 문자를 매칭 (와일드 카드)
        [.]이 여러 번 반복될 때 같은 문자여야함.
        즉, 처음에 와일드 카드에 들어간 값이 반복되는 것으로 인식
        ex)
        lin = 'a.cccb'
        if re.match('a[.]{3,}b',lin):
            print('yes')
        else:
            print('n')

        # n
        ('a.*b'  # yes)

    \s          공백 문자를 매칭

    \S         공백이 아닌 문자를 매칭

    *            *바로 앞에 있는 문자 a가 0부터 무한대로 반복될 수 있다는 의미이다.
            정규식	문자열	Match 여부	설명
        ca*t	ct	Yes	"a"가 0번 반복되어 매치
        ca*t	cat	Yes	"a"가 0번 이상 반복되어 매치 (1번 반복)
        ca*t	caaat	Yes	"a"가 0번 이상 반복되어 매치 (3번 반복)

    *?          바로 앞선 문자에 적용되고 0 혹은 그 이상의 앞선 문자와 매칭을 탐욕적이지 않은 방식으로 표기함.

    +           +는 최소 1번 이상 반복될 때 사용한다.

    +?          바로 앞선 문자에 적용되고 1 혹은 그 이상의 앞선 문자와 매칭을 탐욕적이지 않은 방식으로 표기함.

    { }         반복 횟수를 고정시킬 수 있다.

                ※ {1,}은 +와 동일하며 {0,}은 *와 동일하다.
        ex)
        ca{2}t       "c + a(반드시 2번 반복) + t"
        ca{2,5}t     "c + a(2~5회 반복) + t"

     ?          상관없음

        ex)
        ab?c        "a + b(있어도 되고 없어도 된다) + c"

    문자 클래스 [ ]
        문자 클래스를 만드는 메타 문자인 [와 ] 사이에는 어떤 문자도 들어갈 수 있다.

        ^   문자 클래스에서 반대( NOT ) 의 의미를 갖는다.

        [aeiou]    명세된 집합 문자에 존재하는 단일 문자와 매칭. “a”, “e”, “i”, “o”, “u” 문자만 매칭되는 예제
            ex)
            import re

            x = 'My 2 favorite numbers are 19 and 42'
            y = re.search('[are]+',x)
            print(y)

            ['a', 'r', 'e', 'er', 'are', 'a']
        [a-z0-9]    - 기호로 문자 범위를 명세할 수 있다. 소문자이거나 숫자인 단일 문자만 매칭되는 예제.

        ( )         괄호가 정규표현식에 추가될 때, 매칭을 무시한다. 하지만 findall()을 사용 할 때 전체 문자열보다 매칭된 문자열의 상세한 부속 문자열을 추출할 수 있게 한다.
            문자열 추출

            [자주 사용하는 문자 클래스]



            \d - 숫자와 매치, [0-9]와 동일한 표현식이다.
            \D - 숫자가 아닌 것과 매치, [^0-9]와 동일한 표현식이다.
            \s - whitespace 문자와 매치, [ \t\n\r\f\v]와 동일한 표현식이다. 맨 앞의 빈 칸은 공백문자(space)를 의미한다.
            \S - whitespace 문자가 아닌 것과 매치, [^ \t\n\r\f\v]와 동일한 표현식이다.
            \w - 문자+숫자(alphanumeric)와 매치, [a-zA-Z0-9_]와 동일한 표현식이다.
            \W - 문자+숫자(alphanumeric)가 아닌 문자와 매치, [^a-zA-Z0-9_]와 동일한 표현식이다.
            대문자로 사용된 것은 소문자의 반대임을 추측할 수 있을 것이다.



